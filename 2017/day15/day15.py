# -*- coding: utf-8 -*-
# @Author: shramesh
# @Date:   2017-12-15 01:26:25
# @Last Modified by:   shramesh
# @Last Modified time: 2017-12-15 02:08:09


def match_lowest_16_bits(num1,num2):
	return bin(num1)[2:].zfill(16)[-16:] == bin(num2)[2:].zfill(16)[-16:]

def get_next_gen_A(prev):
	
	next_num =  prev*16807%2147483647 
	if next_num % 4 != 0:
		return get_next_gen_A(next_num)
	else:
		return next_num

def get_next_gen_B(prev):
	next_num = prev*48271%2147483647 
	if next_num % 8 != 0:
		return get_next_gen_B(next_num)
	else:
		return next_num

num_pairs = 5000000
num_matches = 0
prev_a = 634 #starting number for gen A
prev_b = 301 #starting number for gen B

while num_pairs > 0:
	prev_a = get_next_gen_A(prev_a)
	prev_b = get_next_gen_B(prev_b)
	if match_lowest_16_bits(prev_a,prev_b):
		num_matches += 1
	num_pairs -= 1

print num_matches
# assert num_matches == 588, "Number of matches in 40M pairs generated by Gen A and GenB is wrong :("
